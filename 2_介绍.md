Nginx 采取了分阶段资源分配技术，使得它的 CPU 与内存占用率非常低。

热部署。

进程模型与事件模型：

Nginx 采用 master-slave 模型,能够充分利用 SMP 的优势，且能够减少工作进程在磁盘 I/O 的阻塞延迟。当采
用 select()/poll() 调用时，还可以限制每个进程的连接数。

Nginx 在启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程。
Nginx 是以多进程的方式来工作的，当然 Nginx 也是支持多线程的方式的，只是我们主流的方式还是多进程的方式，也是 Nginx 的默认方式。

master 进程主要用来管理 worker 进程。

    1.接收来自外界的信号，向各 worker 进程发送信号；
    2.监控 worker 进程的运行状态， 当 worker 进 程退出后(异常情况下)，会自动重新启动新的 worker 进程

1.基本的网络事件，则是放在 worker 进程中来处理 。

2.多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。

3.worker 进程的个数是 可以设置的，一般我们会设置与机器cpu核数一致。


master 进程在接收到 HUP 信号后是怎么做的呢？

1.会先重新加载配置文件；
2.启动新的 worker 进程，并向所有老的 worker 进程发送信号，告诉他们可以退出了。
3.新的 worker 在启动后，就开始接收新的请求，而老的 worker 在收到来自 master 的信号后，就不再接收 新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出；


    ./nginx -s reload ，就是来重启 Nginx， 
    ./nginx -s stop  停止nginx

当我们提供 80 端口的 http 服务时，一个连接请求过来，每个进程都有可能处理这个连接，怎么做到的呢？

    1.每个 worker 进程都是从 master 进程 fork 过来，在 master 进程里面，先建立好需要 listen 的 socket（listenfd）之后，然后再 fork 出多个 worker 进程。
    2.所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，在读事件里调用 accept 接受该连接。
    3.当一个 worker 进程在 accept 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。

nginx进程模型的好处：
    
    1.对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多；
    2.采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快启动新的 worker 进程。



Nginx 是如何处理事件的：

Nginx 采用了异步非阻塞的方式来处理请求，也就是说，Nginx 是可以同时处理成千上万个请求的。

阻塞调用会进入内核等待，cpu 就会 让出去给别人用了，对单线程的 worker 来说，显然不合适，当网络事件越多时，大家都在等待呢，cpu 空闲下
来没人用，cpu利用率自然上不去了，更别谈高并发了。

非阻塞就是，事件没有准备好，马上返回 EAGAIN，告诉你，事件还没准备好呢，过会再来。

你过一会，再来检查一下事件，直到事件准备好了为止，在这期间，你就可以先去做其它事情，然后
再来看看事件好了没。

虽然不阻塞了，但你得不时地过来检查一下事件的状态，你可以做更多的事情了，但带来的开销也是不小的。



异步非阻塞的事件处理机制，具体到系统调用就是：
像 select/poll/epoll/kque ue 这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。

 epoll 当事件没准备好时，放到 epoll 里面，事件准备好了，我们就去读写，当读写返回 EAGAIN 时，我们将它再次加入到 epoll 里面。
 只要有事件准备好了，我们就去处理它，只有当所有事件都没准备好时，才在 epoll 里面等着。
 这样，我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个了，
 只是在请求间进行不断地切换而已，切换也是因为异步事件未准备好，而主动让出的。
 这里的切换是没有任何代价，你可以理解为循环处理多个准备好的事件，事实上就是这样的。
 与多线程相比，这种事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常的轻量级。
 并发数再多也不会导致无谓的资源浪费（上下文切换）。更多的并发数，只是会占用更多的内存而已。

推荐设置 worker 的个数为 cpu 的核数，原因：

    1.更多的 worker 数，只会导致进程来竞争 cpu 资源了，从而带来不必要的上下文切换。
    2.可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来 cache 的失效。


对于一个基本的 Web 服务器来说，事件通常有三种类型，网络事件、信号、定时器。

    网络事件：通过异步非阻塞可以很好的解决掉。
    信号处理：如果nginx正在等待事件（epoll_wait 时），如果程序收到信号，在信号处理函数处理完后，epoll_wait 会返回错误，然后程序可再次进入 epoll_wait 调用。
    定时器： 由于 epoll_wait 等函数在调用的时候是可以设置一个超时时间的，所以 Nginx 借助这个超时时间来实现定时器。
           
            nginx里面的定时器事件是放在一颗维护定时器的红黑树里面，每次在进入 epoll_wait前，先从该红黑树里面拿到所有定时器事件的最小时间，在计算出 epoll_wait 的超时时间后进入 epoll_wait。
            所以，当没有事件产生，也没有中断信号时，epoll_wait 会超时，也就是说，定时器事件到了。这时，nginx会检查所有的超时事件，将他们的状态设置为超时，然后再去处理网络事件。
           当我们写 Nginx 代码时，在处理网络事件的回调函数时，通常做的第一个事情就是判断超时，然后再去处理网络事件。


